// 2. Divide & Conquer : top-down 하향식 문제 풀이 방식

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
#define SWAP(x, y, z) ((z) = (x), (x) = (y), (y) = (z))

typedef int keytype;
typedef int index;

// 2.1 이분검색 재귀 (원소가 n 개인 정렬된 배열 S 에 검색 키 x 가 있는가?)
index location(const keytype S[], index low, index high, keytype x)
{
    index mid;
    if (low > high)
        return 0;
    else
    {
        mid = (low + high);
        if (x == S[mid])
            return mid;
        else if (x < S[mid])
            return location(S, low, mid - 1, x);
        else
            return location(S, mid + 1, high, x);
    }
}

// 2.2 합병정렬 (n 개 원소를 비내림차순으로 정렬)
void mergesort(int n, vector<int> &S)
{
    if (n > 1)
    {
        int h = n / 2, m = n - h;
        vector<int> U(h + 1), V(m + 1);

        for (int i = 1; i <= h; i++)
            U[i] = S[i]; // Copy S[1..h] to U[1..h]

        for (int i = h + 1; i <= n; i++)
            V[i - h] = S[i]; // copy S[h+1..n] to V[1..n-h]

        mergesort(h, U);
        mergesort(m, V);
    }
}

// 2.3 합병 (정렬된 배열 두개를 정렬상태를 유지하면서 하나로 합병)
void merge(int h, int m, vector<int> U, vector<int> V, vector<int> &S)
{
    int i = 1, j = 1, k = 1;
    while (i <= h && j <= m)
    {
        if (U[i] < V[j])
            S[k] = U[i++];

        else
            S[k] = V[j++];
        k++;
    }

    if (i > h)
        while (j <= m)
            S[k++] = V[j++];
    else
        while (i <= h)
            S[k++] = U[i++];
}
//  입력 배열 S 이외에 추가적인 배열 U , V 를 사용하므로, 추가적으로 만들어지는 배열 원소의 총 개수가 대략 2*n

// 2.4 합병정렬 2 (n 개의 원소를 비내림차순으로 정렬) -> 제자리정렬(in-place sort) : 입력을 저장하는데 필요한 장소 이외의 추가 저장소 사용 X
vector<int> S;
int n;

void mergesort2(int low, int high)
{
    int mid;
    if (low < high)
    {
        mid = (low + high) / 2;
        mergesort2(low, mid);
        mergesort2(mid + 1, high);
        merge2(low, mid, high);
    }
}
// 2.5 합병 2 (합병정렬 2에서 분할하여 정렬한 배열을 합병)
void merge2(int low, int mid, int high)
{
    int i = low, j = mid + 1, k = 0;
    vector<int> U(high - low + 1);

    while (i <= mid && j <= high)
    {
        if (S[i] < S[j])
            U[k] = S[i++];
        else
            U[k] = S[j++];

        k++;
    }

    if (i > mid)
        while (j <= high)
            U[k++] = S[j++];
    else
        while (i <= mid)
            U[k++] = S[i++];

    for (int t = low; t <= high; t++)
        S[t] = U[t - low];
}

// 2.6 빠른정렬 (비내림차순으로 원소가 n 개인 배열을 정렬)
void quicksort(int low, int high)
{
    int pivot;

    if (low < high)
    {
        partition(low, high, pivot);
        quicksort(low, pivot - 1);
        quicksort(pivot + 1, high);
    }
}

// 2.7 분할 (빠른정렬에서 쓸 수 있도록 배열 S 를 분할)
void partition(int low, int high, int &pivot)
{
    int pivotitem = S[low];
    int j = low, temp;

    for (int i = low + 1; i <= high; i++)
    {
        if (S[i] < pivotitem)
        {
            j++;
            SWAP(S[i], S[j], temp);
        }
    }

    pivot = j;
    SWAP(S[low], S[pivot], temp);
}

// 2.8 쉬트라쎈 (Strassen : n 이 2의 거듭제곱일 때 2 개의 n X n 행렬의 곱을 구하시오.) -> n^3 보다 더 나은 시간 복잡도로 !!
// Strassen.cpp
// n = 1 일 때, 곱셈 1번, n > 1 인 두 개의 n X n 행렬이 있을 때, (n/2) X (n/2) 행렬로 7 번의 재귀 호출
// => T(n) = n^(log 7) ~ n^(2.81)

// 2.9 큰 정수 곱셈 (2 개의 큰 정수 u 와 v 를 곱함)
typedef vector<int> LargeInteger;
const int threshold = 1;

void roundup_carry(LargeInteger &v)
{
    int carry = 0;
    for (int i = 0; i < v.size(); i++)
    {
        v[i] += carry;
        carry = v[i] / 10;
        v[i] = v[i] % 10;
    }

    if (carry != 0)
        v.push_back(carry);
}

void ladd(LargeInteger a, LargeInteger b, LargeInteger &c)
{
    c.resize(max(a.size(), b.size()));
    fill(c.begin(), c.end(), 0);
    for (int i = 0; i < c.size(); i++)
    {
        if (i < a.size())
            c[i] += a[i];
        if (i < b.size())
            c[i] += b[i];
    }
    roundup_carry(c);
}

void lmult(LargeInteger a, LargeInteger b, LargeInteger &c)
{
    c.resize(a.size() + b.size() - 1);
    fill(c.begin(), c.end(), 0);
    for (int i = 0; i < c.size(); i++)
        for (int j = 0; j < b.size(); j++)
            c[i + j] += a[i] * b[j];

    roundup_carry(c);
}

void remove_leading_zeros(LargeInteger &v)
{
    while (v.size() != 0 && v.back() == 0)
        v.pop_back();
}

void pow_by_exp(LargeInteger u, int m, LargeInteger &v)
{
    if (u.size() == 0)
        v.resize(0);
    else
    {
        v.resize(u.size() + m);
        fill(v.begin(), v.end(), 0);
        copy(u.begin(), u.end(), v.begin() + m);
    }
}

void rem_by_exp(LargeInteger u, int m, LargeInteger &v)
{
    if (u.size() == 0)
        v.resize(0);
    else
    {
        int k = m < u.size() ? m : u.size();
        v.resize(k);
        copy(u.begin(), u.begin() + k, v.begin());
        remove_leading_zeros(v);
    }
}
void div_by_exp(LargeInteger u, int m, LargeInteger &v)
{
    if (u.size() == 0)
        v.resize(0);
    else
    {
        int k = m < u.size() ? u.size() - m : 0;
        v.resize(k);
        if (k != 0)
            copy(u.begin() + m, u.end(), v.begin());
        remove_leading_zeros(v);
    }
}

void prod(LargeInteger u, LargeInteger v, LargeInteger &r)
{
    LargeInteger x, y, w, z;
    LargeInteger t1, t2, t3, t4, t5, t6, t7, t8;
    int n, m;

    n = max(u.size(), v.size());
    if (u.size() == 0 || v.size() == 0)
        r.resize(0);
    else if (n <= threshold)
        lmult(u, v, r);
    else
    {
        m = n / 2;
        div_by_exp(u, m, x); rem_by_exp(u, m, y);
        div_by_exp(v, m, w); rem_by_exp(v, m, z);

        prod(x, w, t1); pow_by_exp(t1, 2 * m, t2); //t2 = prod(x,w) * 10^(2*m)
        prod(x, z, t3); prod(w, y, t4); ladd(t3, t4, t5); pow_by_exp(t5, m, t6); // t6 = (prod(x,z) + prod(w,y)) * 10^m
        prod(y, z, t7); ladd(t2, t6, t8); ladd(t8, t7, r); // r = t2 + t6 + prod(y,z)
    }
}

/*
임계값의 결정
- 이상적으로는 n 의 최적 임계점이 되는 값을 찾고 싶음.
- 이 값보다 더 작은 입력 사례에 대해서는 계속 분할하는 것보다 다른 알고리즘을 호출하여 사용하는 편이 최소한 빠르고,
  큰 사례에 대해서는 계속 분할하는 편이 더 빠르게 되는 사례크기가 바로 최적 임계값이 됨.
- 항상 최적 임계값을 구할 수 있는 것은 아님!!

분할정복법을 사용할 수 없는 경우
- 크기 n 인 사례가 거의 n 에 가까운 크기의 두 개 이상의 사례로 분할될 때
- 크기 n 인 사례가 n / c 크기의 거의 n 개 사례로 분할될 때
*/
