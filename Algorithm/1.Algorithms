#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
#define SWAP(x, y, z) ((z) = (x), (x) = (y), (y) = (z))

// 1.1 순차 검색 (원소가 n 개인 배열 S 에 원소 x 가 있는가? )
typedef int keytype;
typedef int index;

void search(int n, const keytype S[], keytype x, index &location)
{
    location = 1;
    while (location <= n && S[location] != x)
        location++;

    if (location > n)
        location = 0;
}

// 1.2 배열의 수 더하기 ( 수가 n 개인 배열 S 에 있는 수를 모두 더하시오. )
int sum(int n, vector<int> &S)
{
    int i, result = 0;
    for (i = 1; i <= n; i++)
        result += S[i];

    return result;
}

// 1.3 교환정렬 ( 비내림차순으로 n 개의 키를 정렬하시오. )
void exchange(int n, vector<int> &S)
{
    int i, j, temp;

    for (i = 1; i <= n - 1; i++)
        for (j = i + 1; j <= n; j++)
            if (S[j] < S[i])
                SWAP(S[i], S[j], temp); // exchange S[i] and S[j]
}

// 1.4 행렬곱셈 ( 두 n X n 행렬의 곱을 구하시오. )
typedef vector<vector<int>> matrix_t;

void matrixmul(int n, matrix_t A, matrix_t B, matrix_t &C)
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            C[i][j] = 0;
            for (int k = 1; k <= n; k++)
                C[i][j] += A[i][k] * B[k][j];
        }
}

// 1.5 이분검색 ( 원소가 n 개인 정렬된 배열 S 에서 원소 x 를 찾으시오. )
void binsearch(int n, vector<int> &S, int x, int &location)
{
    int low, high, mid;
    low = 1;
    high = n;
    location = 0;

    while (low <= high && location == 0)
    {
        mid = (low + high) / 2;
        if (x == S[mid])
            location = mid;
        else if (x < S[mid])
            high = mid - 1;
        else // x > S[mid]
            low = mid + 1;
    }
}

// 1.6 n번째 피보나치 수 구하기 - 재귀 ( 피보나치 수열에서 n 번째 수를 구하시오. )
typedef unsigned long long LongInt;

LongInt fib(LongInt n)
{
    if (n <= 1)
        return n;
    else
        return fib(n - 1) + fib(n - 2);
}

// 1.7 n번째 피보나치 항 구하기 - 반복 ( 피보나치 수열에서 n 번째 항을 구하시오. )

int fib2(int n)
{
    index i;
    int f[n];
    f[0] = 0;
    if (n > 0)
    {
        f[1] = 1;
        for (i = 2; i <= n; i++)
            f[i] = f[i - 1] + f[i - 2];
    }
    return f[n];
}

/*
시간 복잡도 분석
- T(n) : 일정 시간복잡도(every-case time complexity) , 입력 크기 n 에 대해서 알고리즘이 단위연산을 실행하는 횟수

- W(n) : 최악 시간복잡도(worst-case time complexity) , 입력 크기 n 에 대해서 알고리즘이 실행할 단위연산의 최대 횟수

- A(n) : 평균 시간복잡도(average-case time complexity) , 입력 크기 n 에 대해서 알고리즘이 수행할 단위연산의 평균 횟수

- B(n) : 최선 시간복잡도(best-case time complexity) , 입력 크기 n 에 대해서 알고리즘이 실행할 단위연산의 최소 횟수

=> 시간 복잡도 별 실행 시간 : n -> log(n) -> n*log(n) -> n^2 -> n^3 -> 2^n -> n! 
    ( const -> log -> linear -> linear log -> quadratic -> cubic -> exponential -> factorial )

메모리(공간) 복잡도 분석

Asymptotic Notations : big O , Omega , Theta
- big O : 함수의 점근적인 upper bound 를 정함 , O(f(n)) : g(n) <= c * f(n)
- Omega : 함수의 점근적인 lower bound 를 정함 , Omega(f(n)) : g(n) >= c * f(n)
- Theta : big O 와 Omega 의 교집합, 차수(order) , Theta(f(n)) : c * f(n) <= g(n) <= d * f(n) 
*/
