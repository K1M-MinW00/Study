// 3. Dynamic programming : bottom-up 상향식 접근 방법
// 1)문제의 입력사례에 대해서 해답을 계산하는 재귀 관계식 (recursive property) 을 세운다.
// 2)작은 입력사례부터 먼저 해결하는 상향식 방법을로 전체 입력사례에 대한 해답을 구한다.

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;
#define SWAP(x, y, z) ((z) = (x), (x) = (y), (y) = (z))

// 3.1-1 분할정복으로 이항계수 구하기
typedef unsigned long long LongInteger;

LongInteger bin(int n, int k)
{
    if (k == 0 || k == n)
        return 1;
    else
        return bin(n - 1, k - 1) + bin(n - 1, k);
}

// 3.1-2 동적계획으로 이항계수 구하기
LongInteger bin2(int n, int k)
{
    vector<vector<LongInteger>> B(n + 1, vector<LongInteger>(n + 1));

    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= min(i, k); j++)
            if (j == 0 || j == i)
                B[i][j] == 1;
            else
                B[i][j] = B[i - 1][j] + B[i - 1][j - 1];

    return B[n][k];
}

// 3.2 Floyd's Algorithm for Shortest Paths (가중치 포함 그래프의 각 마디에서 다른 모든 마디로 가는 최단 경로를 모두 계산하시오)
//  W[i][j] : 정점 i 에서 정점 j 로 가는 이음선의 가중치 , D[i][j] : 정점 i 에서 정점 j 로 가는 최단경로의 길이
typedef vector<vector<int>> matrix_t;

void floyd(int n, matrix_t &W, matrix_t &D)
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            D[i][j] = W[i][j];

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                D[i][j] = min(D[i][j], D[i][k] + D[k][j]);
}

// 3.2 Floyd's Algorithm for Shortest Paths (가중치 포함 그래프의 각 마디에서 다른 모든 마디로 가는 최단 경로를 모두 계산하시오)
//  P[i][j] : i 에서 j 로 가는 최단경로의 중간에 놓여있는 마디가 최소한 하나는 있는 경우, 그 놓여있는 마디 중에서 가장 큰 인덱스

void floyd2(int n, matrix_t &W, matrix_t &D, matrix_t &P)
{
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
        {
            D[i][j] = W[i][j];
            P[i][j] = 0;
        }

    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (D[i][j] > D[i][k] + D[k][j])
                {
                    D[i][j] = D[i][k] + D[k][j];
                    P[i][j] = k;
                }
}

void path(matrix_t &P, int u, int v, vector<int> &p)
{
    int k = P[u][v];
    if (k != 0)
    {
        path(P, u, k, p);
        p.push_back(k);
        path(P, k, v, p);
    }
}

// 3.3 최소 곱셈 (행렬 n 개를 곱하는데 필요한 원소단위 곱셈의 최소 횟수와 최소 횟수로 행렬 곱셈을 하는 순서를 구하시오)
#define INF 999

int minimum(int i, int j, int &mink, vector<int> &d, matrix_t &M)
{
    int minValue = INF, value;
    for (int k = i; k <= j; k++)
    {
        value = M[i][k] + M[k + 1][j] + d[i - 1] * d[k] * d[j];
        if (minValue > value)
        {
            minValue = value;
            mink = k;
        }
    }

    return minValue;
}
void minmult(int n, vector<int> &d, matrix_t &M, matrix_t &P)
{
    for (int i = 1; i < -n; i++)
        M[i][i] = 0;

    for (int diagonal = 1; diagonal <= n - 1; diagonal++)
        for (int i = 1; i <= n - diagonal; i++)
        {
            int j = i + diagonal, k;
            M[i][j] = minimum(i, j, k, d, M);
            P[i][j] = k;
        }
}

//3.4-1 이분검색트리의 검색 (이분검색트리에서 검색키와 같은 원소가 있는 마디를 찾으시오, 찾는 원소는 나무에 있다고 가정한다.)
typedef struct node *node_ptr;
typedef struct node
{
    int key;
    node_ptr left,right;
}node_t;

void search(node_ptr tree, int keyin, node_ptr &p)
{
    bool found;

    p=tree;
    found = false;
    while(!found)
    {
        if(p->key== keyin)
            found = tree;
        else if(keyin < p->key)
            p = p->left;
        else // keyin > p->key
            p = p->right;
    }
}

//3.4-2 최적 이분검색트리 (주어진 원소의 집합을 가지고 최적 이분검색트리를 구축한다. 여기서 각 원소에 대해 검색키가 될 확률이 주어진다.)
// n : 원소의 개수 , p : index 범위가 1~n 까지인 실수 배열 , p[i] : i 째 원소를 찾을 확률

void optsearchtree(int n,vector<int>& p,matrix_t& A, matrix_t& R)
{
    for(int i=1;i<=n;i++)
    {
        A[i][i-1] = 0;
        A[i][i] = p[i];
        R[i][i-1] = 0;
        R[i][i]= i;
    }
    A[n+1][n]= R[n+1][n]=0;

    for(int diagonal = 1; diagonal <= n-1; diagonal++)
        for(int i=1;i<=n-diagonal;i++)
        {
            int j=i+diagonal, k;
            A[i][j] = minimum(i,j,k,p,A);
            R[i][j] = k;
        }
}

node_ptr tree(int i,int j,vector<int>& keys, matrix_t &R)
{
    int k = R[i][j];
    if(k==0)
        return NULL;
    else
    {
        node_ptr node;
        node->key = keys[k];
        node->left= tree(i,k-1,keys,R);
        node->right = tree(k+1,j,keys,R);
        return node;
    }    
}

/*
최적의 원칙(principle of optimality)
- 어떤 문제의 입력사례의 최적해가 그 입력사례를 분할한 부분사례에 대한 최적해를 항상 포함하고 있으면, 그 문제는 최적의 원칙이 성립한다고 한다.
ex) k 를 i 에서 j 로 가는 최적경로 상의 마디라고 하면, i 에서 k 로 가는 부분경로와 k 에서 j 로 가는 부분경로도 반드시 최적이어야 한다.


*/
