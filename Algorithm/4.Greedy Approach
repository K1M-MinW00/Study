// 4. Greedy Approach : 순서대로 답을 하나씩 모아서 최종 답을 구축하는데, 가장 좋아 보이는 답을 선택하여 모음.
// 선택할 당시(locally) 는 최적이지만, 전체적으로(globally) 최적인 해를 구하고 싶음.
// 최적의 해를 구하고 싶지만, 항상 최적인 해를 얻는다는 보장이 없으므로, 최적인 해답을 얻는지 확인하는 절차가 필요
// 1) 선택 과정(selection procedure) : 집합에 추가할 다음 원소를 고른다. 그 당시 최적을 선택하는 탐욕 기준에 따라 선택
// 2) 적절성 검사(feasibility check) : 새로운 집합이 해답이 되기 적절한지 검사
// 3) 해답 점검(solution check) : 새로운 집합이 문제의 해답인지 결정

#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <map>

using namespace std;

// 4.1-1 Prim's Algorithm : 가장 가까운 마디 중 최소 가중치를 가진 이음선으로 연결
// 1 부터 n 까지의 2차원 배열 W 로 가중치포함 비방향 그래프를 표현
// W[i][j] : i번째 마디와 j번째 마디를 연결하는 이음선의 가중치

typedef vector<vector<int>> matrix_t;
typedef vector<pair<int, int>> set_of_edges;
typedef pair<int, int> edge_t;

#define INF 9999
void prim(int n, matrix_t &W, set_of_edges &F)
{
    int vnear, min;
    vector<int> nearest(n + 1), distance(n + 1);

    F.clear(); // F = { }

    for (int i = 2; i <= n; i++)
    {
        nearest[i] = 1; //  v_1 부터 시작
        distance[i] = W[1][i];
    }

    for (int k = 1; k < n; k++)
    {
        min = INF;
        for (int i = 2; i <= n; i++)
            if (0 <= distance[i] && distance[i] < min)
            {
                min = distance[i];
                vnear = i;
            }

        F.push_back(make_pair(vnear, nearest[vnear]));
        distance[vnear] = -1; // Y 집합에 추가한다는 의미

        for (int i = 2; i <= n; i++) // Y 에 속하지 않은 각 마디에 대하여 Y로부터의 거리를 갱신
        {
            if (distance[i] > W[i][vnear])
            {
                distance[i] = W[i][vnear];
                nearest[i] = vnear;
            }
        }
    }
} // 시간 복잡도 : Theta(n^2) , n : 정점의 개수

// 4.1-2 Kruskal's Algorithm : 각 마디마다 자신만 포함하는 V의 서로소 부분집합들을 만들고 시작하여, 가중치가 작은 것부터 차례로 이음선 검사
// 정점 u 와 v 를 잇는 이음선의 가중치 w 로 edge 표현
typedef struct edge
{
    int u, v, w;
} edge_t2;

struct edge_compare
{
    bool operator()(edge_t2 e1, edge_t2 e2)
    {
        if (e1.w > e2.w)
            return true;
        else
            return false;
    }
};

typedef vector<edge_t2> set_of_edges2;
typedef priority_queue<edge_t2, vector<edge_t2>, edge_compare> PriorityQueue;
vector<int> dset;

void dset_init(int n)
{
    dset.resize(n + 1);
    for (int i = 1; i <= n; i++)
        dset[i] = 1;
}

int dset_find(int i)
{
    while (dset[i] != i)
        i = dset[i];
    return i;
}

void dset_merge(int p, int q)
{
    dset[p] = q;
}

void kruskal(int n, int m, set_of_edges2 &E, set_of_edges2 &F)
{
    int p, q;
    edge_t2 e;
    PriorityQueue PQ;

    for (edge_t2 e : E) // E 에 속한 m 개의 이음선을 오름차순으로 정렬
        PQ.push(e);

    F.clear();
    dset_init(n);

    while (F.size() < n - 1) // F 에 n-1 개의 이음선이 있을 때 while 루프 탈출
    {
        e = PQ.top(); // 아직 고려하지 않은 이음선 중 가중치가 최소인 이음선
        PQ.pop();
        p = dset_find(e.u);
        q = dset_find(e.v);
        if (p != q)
        {
            dset_merge(p, q);
            F.push_back(e); // e 를 F 에 추가
        }
    }
} //  시간복잡도 : Theta(n^2 * log n) , Theta(m * log m) , m : 간선의 개수, n : 정점의 개수

// 4.2 Dijkstra's Algorithm for Single-Source Shortest Paths : 하나의 특정 마디에서 다른 모든 마디로 가는 최단경로 구하기
// W : 마디가 n 개 있는 연결된 가중치포함 방향그래프 , W[i][j] : i번째 마디와 j번째 마디를 잇는 이음선 상의 가중치

void dijkstra(int n, matrix_t &W, set_of_edges &F)
{
    int vnear, min;
    vector<int> touch(n + 1), length(n + 1);

    F.clear();

    for (int i = 2; i <= n; i++)
    {
        touch[i] = 1;        // v_1 에서 출발하는 현재 최단경로의 마지막 마디를 v_1 으로 초기화
        length[i] = W[1][i]; // 그 경로의 길이는 v_1 에서의 이음선 상의 가중치로 초기화
    }

    for (int k = 2; k <= n; k++)
    {
        min = INF;
        for (int i = 2; i <= n; i++) // 최단경로를 가지는지 각 마디를 점검
            if (0 <= length[i] && length[i] < min)
            {
                min = length[i];
                vnear = i;
            }
        F.push_back(make_pair(touch[vnear], vnear)); // touch[vnear] 가 인덱스인 마디에서 vnear 가 인덱스인 마디로 가는 이음선을 F 에 추가

        for (int i = 2; i <= n; i++)
            if (length[i] > length[vnear] + W[vnear][i])
            {
                length[i] = length[vnear] + W[vnear][i]; // Y에 속하지 않는 각 마디에 대해서, 최단경로를 바꿈
                touch[i] = vnear;                        // vnear 가 인덱스인 마디를 Y 에 추가
            }
        length[vnear] = -1;
    }
}

// 4-3 마감시간이 있는 스케줄 짜기
// 작업의 수 : n , i번째 마감시간 : deadline[i] , 마감시간 정수배열 deadline 은 내림차순으로 정렬되어 있음
typedef vector<int> sequence_of_integer;

bool is_feasible(sequence_of_integer &K, sequence_of_integer &deadline)
{
    for (int i = 1; i < K.size(); i++)
        if (i > deadline[K[i]])
            return false;
    return true;
}

void schedule(int n, sequence_of_integer &deadline, sequence_of_integer &J)
{
    sequence_of_integer K;
    J.clear();
    J.push_back(0);
    J.push_back(1);

    for (int i = 2; i <= n; i++)
    {
        K.resize(J.size());
        copy(J.begin(), J.end(), K.begin());
        int j = 1;
        while (j < K.size() && deadline[K[j]] <= deadline[i])
            j++;
        K.insert(K.begin() + j, i);
        if (is_feasible(K, deadline))
        {
            J.resize(K.size());
            copy(K.begin(), K.end(), J.begin());
        }
    }
} // 시간 복잡도 : Theta(n^2)

// 4-4 허프만 코드 : 데이터 파일을 코드화 하는 효율적인 방법
typedef struct node *node_ptr;
typedef struct node
{
    char symbol;   // the value of a character
    int frequency; // the number of times the character is in the file
    node_ptr left, right;
} node_t;

struct compare
{
    bool operator()(node_ptr p, node_ptr q)
    {
        return p->frequency > q->frequency;
    }
};

typedef priority_queue<node_ptr, vector<node_ptr>, compare> PriorityQueue2;

node *create_node(char s, int f)
{
    node *nodeptr = new node;
    nodeptr->frequency = f;
    nodeptr->symbol = s;
    nodeptr->left = NULL;
    nodeptr->right = NULL;

    return nodeptr;
}

void huffman(int n, PriorityQueue2 &PQ)
{
    for (int i = 1; i <= n - 1; i++)
    {
        node_ptr p = PQ.top();
        PQ.pop();
        node_ptr q = PQ.top();
        PQ.pop();
        node_ptr r = create_node('+', p->frequency + q->frequency);
        r->left = p;
        r->right = q;
        PQ.push(r);
    }
}

void make_encoder(node_ptr node, string code, map<char, string> &encoder)
{
    if (node->symbol != '+')
    {
        encoder[node->symbol] = code;
    }
    else
    {
        make_encoder(node->left, code + '0', encoder);
        make_encoder(node->right, code + "1", encoder);
    }
}

void decode(node_ptr root, node_ptr node, string s, int i)
{
    if (i <= s.length())
    {
        if (node->symbol != '+')
        {
            cout << node->symbol;
            decode(root, root, s, i);
        }
        else
        {
            if (s[i] == '0')
                decode(root, node->left, s, i + 1);
            else
                decode(root, node->right, s, i + 1);
        }
    }
}

void preorder(node *node)
{
    if (node != NULL)
    {
        printf("%c:%d ", node->symbol, node->frequency);
        preorder(node->left);
        preorder(node->right);
    }
}
void inorder(node *node)
{
    if (node != NULL)
    {
        inorder(node->left);
        printf("%c:%d ", node->symbol, node->frequency);
        inorder(node->right);
    }
}

// 4.5-1 Knapsack - Greedy Algorithm for Fractional Knapsack Problem (단위 무게 당 가격이 가장 비싼 것)
typedef struct item *item_ptr;
typedef struct item
{
    int id;
    int weight;
    int profit;
    int profit_per_unit;
} item_t;

int n, W;
vector<item_t> items;

bool compare_item(item_t i, item_t j)
{
    if (i.profit_per_unit > j.profit_per_unit)
        return true;
    return false;
};

void knapsack1(int &maxprofit, int &totweight)
{
    maxprofit = totweight = 0;

    for (int i = 1; i <= n; i++)
    {
        if (totweight + items[i].weight <= W)
        {
            maxprofit += items[i].profit;
            totweight += items[i].weight;
        }
        else
        {
            maxprofit += (W - totweight) * items[i].profit_per_unit;
            totweight += (W - totweight);
            break; // 계속할 필요 X
        }
    }
}

// 4.5-2 Knapsack - Simple Dynamic programming for the 0-1 Knapsack Problem
//  n : 물건 개수, w[] : 물건의 무게 (오름차순) , W : 배낭에 담을 수 있는 무게, P[n][W] : 남은 물건과 담을 수 있는 배낭 무게
int knapsack2(int n, int W, int w[], int p[], vector<vector<int>> &P)
{
    if (n == 0 || W <= 0)
        return 0;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= W; j++)
            P[i][j] = (w[i] > j) ? P[i - 1][j] : max(P[i - 1][j], p[i] + P[i - 1][j - w[i]]);

    return P[0][W];
}

// 4.5-3 Knapsack - Enhanced Dynamic programming for the 0-1 Knapsack Problem
//  n : 물건 개수, w[] : 물건의 무게 (오름차순) , W : 배낭에 담을 수 있는 무게, P[n][W] : 남은 물건과 담을 수 있는 배낭 무게
int knapsack3(int n, int W, int w[], int p[], map<pair<int, int>, int> &P)
{
    if (n == 0 || W <= 0)
        return 0;

    int lvalue = (P.find(make_pair(n - 1, W)) != P.end()) ? P[make_pair(n - 1, W)] : knapsack3(n - 1, W, w, p, P);                      // 담지 않는 경우
    int rvalue = (P.find(make_pair(n - 1, W - w[n])) != P.end()) ? P[make_pair(n - 1, W - w[n])] : knapsack3(n - 1, W - w[n], w, p, P); // 담는 경우
    P[make_pair(n, W)] = (w[n] > W) ? lvalue : max(lvalue, p[n] + rvalue);

    return P[make_pair(n, W)];
}

/*
 Prim 알고리즘 : Theta(n^2) , Kruskal 알고리즘 : Theta(n^2 * log n) , Theta(m * log m) , Dijkstra 알고리즘 : Theta(n^2)
 - Sparse Graph 의 경우 , Kruskal 알고리즘은 Theta(n * log n)으로 Prim 알고리즘보다 빠름
 - Dense Grpah 의 경우, Kruskal 알고리즘은 Theta(n^2 * log n)Prim 알고리즘보다 느림


 허프만 코드
 - Fixed-length binary code : 각 문자를 표현하는 비트의 개수가 일정. 쓰기 쉽고 편리
 - variable-length binary code : 각 문자마다 표현하는 비트의 개수가 다름. 데이터 압축 관점에서 훨씬 효율적
 - prefix code : 전치코드 , 한 문자의 코드워드가 다른 문자의 코드워드의 앞부분이 될 수 없음

 - 최적 이진 전치코드에 해당되는 이진트리는 Full Tree. 잎이 아닌 마디는 모두 자식 마디가 2개

*/
